import { supabase } from '@/lib/supabase';
import { CheckoutData, Order } from '@/types/order';

export const orderService = {
  // Create new order (supports guest checkout with null userId)
  // Uses backend API to handle emails and notifications
  async createOrder(checkoutData: CheckoutData, userId: string | null) {
    const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
    
    // Calculate totals
    const subtotal = checkoutData.items.reduce((sum, item) => sum + item.subtotal, 0);
    const deliveryFee = checkoutData.delivery_option.price;
    const tax = subtotal * 0.0; // Ghana VAT if applicable
    const total = subtotal + deliveryFee + tax;

    // Order number will be generated by backend for sequential numbering
    // Frontend should not generate order number - backend handles it

    // Map items for backend
    // Calculate unit_price including variant adjustments
    const order_items = checkoutData.items.map((item) => {
      // Calculate base price
      const basePrice = item.discount_price || item.original_price || 0;
      
      // Calculate variant adjustments from selected_variants
      const variantAdjustments = Object.values(item.selected_variants || {}).reduce(
        (sum: number, variant: any) => {
          // Handle both VariantOption format (price_modifier) and ProductVariant format (price_adjustment)
          const adjustment = variant.price_adjustment ?? variant.price_modifier ?? 0;
          return sum + (Number(adjustment) || 0);
        },
        0
      );
      
      // Unit price should be base price + variant adjustments
      const unitPrice = basePrice + variantAdjustments;
      
      // Ensure subtotal is calculated correctly
      const calculatedSubtotal = item.subtotal || (unitPrice * item.quantity);
      
      return {
        product_id: item.id,
        product_name: item.name,
        product_image: item.thumbnail,
        quantity: item.quantity,
        unit_price: unitPrice, // Include variant adjustments in unit_price
        subtotal: calculatedSubtotal,
        selected_variants: item.selected_variants,
      };
    });

    // Try to call backend API first, fallback to Supabase if it fails
    try {
      const orderPayload = {
        user_id: userId,
        // order_number not provided - backend will generate sequential number
        subtotal,
        discount: 0,
        tax,
        delivery_fee: deliveryFee,
        total,
        payment_method: checkoutData.payment_method,
        delivery_address: checkoutData.delivery_address, // Backend will map this to shipping_address
        delivery_option: checkoutData.delivery_option,
        notes: checkoutData.notes || null,
        payment_reference: checkoutData.payment_reference || null, // Include payment reference for transaction linking
        order_items,
        // Pre-order fields
        is_pre_order: (checkoutData as any).is_pre_order || false,
        pre_order_shipping_option: (checkoutData as any).pre_order_shipping_option || null,
        estimated_arrival_date: (checkoutData as any).estimated_arrival_date || null,
      };
      
      console.log('Creating order via backend API:', {
        API_URL,
        endpoint: `${API_URL}/api/orders`,
        payload: {
          ...orderPayload,
          order_items: orderPayload.order_items.map(item => ({
            product_id: item.product_id,
            quantity: item.quantity,
            unit_price: item.unit_price,
          })),
        },
      });
      
      const response = await fetch(`${API_URL}/api/orders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderPayload),
      });
      
      console.log('Backend API response:', {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
      });

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data;
        } else {
          throw new Error(result.message || 'Order creation failed');
        }
      } else {
        // Try to parse error response
        let errorMessage = 'Backend API failed';
        try {
          const errorData = await response.json();
          errorMessage = errorData.message || errorData.error || errorMessage;
          console.error('Backend API error response:', {
            status: response.status,
            statusText: response.statusText,
            error: errorData,
          });
        } catch (parseError) {
          errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
          console.error('Backend API error (non-JSON):', {
            status: response.status,
            statusText: response.statusText,
          });
        }
        throw new Error(errorMessage);
      }
    } catch (apiError: any) {
      // Fallback to direct Supabase insert if backend API fails
      console.warn('Backend API failed, using Supabase fallback:', {
        error: apiError,
        message: apiError?.message,
        stack: apiError?.stack,
      });
      
      const { supabase } = await import('@/lib/supabase');
      
      // Generate sequential order number for fallback (same format as backend: ORD-XXXDDMMYY)
      // This should rarely be used - backend API should always work
      const now = new Date();
      const day = String(now.getDate()).padStart(2, '0');
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const year = String(now.getFullYear()).slice(-2);
      const dateStr = `${day}${month}${year}`;
      
      // Get last order number for today to generate sequential number
      try {
        const { data: lastOrder } = await supabase
          .from('orders')
          .select('order_number')
          .gte('created_at', new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString())
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        let sequence = 1;
        if (lastOrder && lastOrder.order_number) {
          // Extract sequence from last order number (ORD-XXXDDMMYY)
          const match = lastOrder.order_number.match(/ORD-(\d{3})/);
          if (match) {
            sequence = parseInt(match[1]) + 1;
            // Reset to 1 if sequence exceeds 999
            if (sequence > 999) sequence = 1;
          }
        }
        
        const sequenceStr = String(sequence).padStart(3, '0');
        var orderNumber = `ORD-${sequenceStr}${dateStr}`;
      } catch (orderNumError) {
        // Fallback to timestamp-based number if query fails
        const sequenceStr = String(Date.now()).slice(-3);
        var orderNumber = `ORD-${sequenceStr}${dateStr}`;
      }
      
      // Create order directly in Supabase (fallback - backend API should be used)
      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert([
          {
            user_id: userId,
            order_number: orderNumber, // Sequential order number (same format as backend)
            status: 'pending',
            subtotal,
            discount: 0,
            shipping_fee: deliveryFee, // Use shipping_fee instead of delivery_fee
            tax,
            total,
            payment_method: checkoutData.payment_method || 'cash_on_delivery',
            payment_status: 'pending',
            shipping_address: checkoutData.delivery_address, // Map to shipping_address
            notes: checkoutData.notes || null,
          },
        ])
        .select()
        .single();

      if (orderError) {
        console.error('Supabase order creation error:', {
          error: orderError,
          message: orderError.message,
          code: orderError.code,
          details: orderError.details,
          hint: orderError.hint,
        });
        throw new Error(orderError.message || 'Failed to create order');
      }

      // Create order items
      const orderItems = checkoutData.items.map((item) => ({
        order_id: order.id,
        product_id: item.id,
        product_name: item.name,
        product_image: item.thumbnail,
        quantity: item.quantity,
        unit_price: item.discount_price || item.original_price,
        total_price: item.subtotal, // Use total_price as per schema
        selected_variants: item.selected_variants,
      }));

      const { error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems);

      if (itemsError) {
        console.error('Supabase order items creation error:', {
          error: itemsError,
          message: itemsError.message,
          code: itemsError.code,
          details: itemsError.details,
          hint: itemsError.hint,
        });
        throw new Error(itemsError.message || 'Failed to create order items');
      }

      return order;
    }
  },

  // Get user orders
  async getUserOrders(userId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return data || [];
  },

  // Get order by ID
  async getOrderById(orderId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('id', orderId)
      .single();

    if (error) throw error;

    return data;
  },

  // Get order by order number
  async getOrderByNumber(orderNumber: string): Promise<Order | null> {
    try {
      const { data, error } = await supabase
        .from('orders')
        .select(`
          *,
          items:order_items(*)
        `)
        .eq('order_number', orderNumber.toUpperCase().trim())
        .single();

      if (error) {
        // If order not found, return null instead of throwing
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }

      if (!data) return null;

      // Transform the data to match Order interface
      const order: Order = {
        id: data.id,
        user_id: data.user_id,
        order_number: data.order_number,
        status: data.status,
        items: (data.items || []).map((item: any) => ({
          id: item.id,
          order_id: item.order_id,
          product_id: item.product_id,
          product_name: item.product_name,
          product_image: item.product_image,
          quantity: item.quantity,
          unit_price: item.unit_price,
          subtotal: item.subtotal || (item.unit_price * item.quantity),
          selected_variants: item.selected_variants || {},
        })),
        subtotal: data.subtotal || 0,
        discount: data.discount || 0,
        delivery_fee: data.delivery_fee || data.shipping_fee || 0,
        tax: data.tax || 0,
        total: data.total || 0,
        payment_method: data.payment_method,
        payment_status: data.payment_status,
        delivery_address: data.delivery_address || data.shipping_address || {},
        delivery_option: data.delivery_option || {},
        tracking_number: data.tracking_number,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        delivered_at: data.delivered_at,
      };

      return order;
    } catch (error: any) {
      console.error('Error fetching order by number:', error);
      // Return null if order not found, throw for other errors
      if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
        return null;
      }
      throw error;
    }
  },

  async getOrderByNumberAndEmail(orderNumberOrId: string, email: string): Promise<Order | null> {
    try {
      // Use backend API to bypass RLS and verify email
      const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
      
      try {
        const response = await fetch(`${API_URL}/api/orders/track`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            order_number_or_id: orderNumberOrId,
            email: email.trim().toLowerCase(),
          }),
        });

        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            // Transform the data to match Order interface
            const data = result.data;
            const order: Order = {
              id: data.id,
              user_id: data.user_id,
              order_number: data.order_number,
              status: data.status,
              items: (data.items || data.order_items || []).map((item: any) => ({
                id: item.id,
                order_id: item.order_id,
                product_id: item.product_id,
                product_name: item.product_name,
                product_image: item.product_image,
                quantity: item.quantity,
                unit_price: item.unit_price,
                subtotal: item.subtotal || (item.unit_price * item.quantity),
                selected_variants: item.selected_variants || {},
              })),
              subtotal: data.subtotal || 0,
              discount: data.discount || 0,
              delivery_fee: data.delivery_fee || data.shipping_fee || 0,
              tax: data.tax || 0,
              total: data.total || 0,
              payment_method: data.payment_method,
              payment_status: data.payment_status,
              delivery_address: data.delivery_address || data.shipping_address || {},
              delivery_option: data.delivery_option || {},
              tracking_number: data.tracking_number,
              notes: data.notes,
              created_at: data.created_at,
              updated_at: data.updated_at,
              delivered_at: data.delivered_at,
            };
            return order;
          } else {
            // Order not found or email doesn't match
            return null;
          }
        } else if (response.status === 404) {
          // Order not found
          return null;
        } else {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || 'Failed to fetch order');
        }
      } catch (apiError: any) {
        console.warn('Backend API failed, trying Supabase fallback:', apiError);
        
        // Fallback to Supabase direct query
        // First, try to find order by order_number
        let { data, error } = await supabase
          .from('orders')
          .select(`
            *,
            items:order_items(*),
            user:users!orders_user_id_fkey(id, email)
          `)
          .eq('order_number', orderNumberOrId)
          .maybeSingle();

        // If not found by order_number, try by id
        if (error || !data) {
          const { data: dataById, error: errorById } = await supabase
            .from('orders')
            .select(`
              *,
              items:order_items(*),
              user:users!orders_user_id_fkey(id, email)
            `)
            .eq('id', orderNumberOrId)
            .maybeSingle();
          
          data = dataById;
          error = errorById;
        }

        if (error) {
          console.error('Supabase query error:', {
            code: error.code,
            message: error.message,
            details: error.details,
            hint: error.hint,
          });
          
          // If order not found, return null instead of throwing
          if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
            return null;
          }
          throw new Error(`Database error: ${error.message || 'Unknown error'}`);
        }

        if (!data) return null;

        // Check if email matches
        // Email can be in:
        // 1. user.email (if order has a user_id)
        // 2. delivery_address.email or shipping_address.email (for guest orders)
        const userEmail = data.user?.email?.toLowerCase();
        const deliveryEmail = (data.delivery_address?.email || data.shipping_address?.email)?.toLowerCase();
        const providedEmail = email.toLowerCase().trim();

        const emailMatches = 
          userEmail === providedEmail || 
          deliveryEmail === providedEmail;

        if (!emailMatches) {
          // Email doesn't match - return null for security
          return null;
        }

        // Transform the data to match Order interface
        const order: Order = {
          id: data.id,
          user_id: data.user_id,
          order_number: data.order_number,
          status: data.status,
          items: (data.items || []).map((item: any) => ({
            id: item.id,
            order_id: item.order_id,
            product_id: item.product_id,
            product_name: item.product_name,
            product_image: item.product_image,
            quantity: item.quantity,
            unit_price: item.unit_price,
            subtotal: item.subtotal || (item.unit_price * item.quantity),
            selected_variants: item.selected_variants || {},
          })),
          subtotal: data.subtotal || 0,
          discount: data.discount || 0,
          delivery_fee: data.delivery_fee || data.shipping_fee || 0,
          tax: data.tax || 0,
          total: data.total || 0,
          payment_method: data.payment_method,
          payment_status: data.payment_status,
          delivery_address: data.delivery_address || data.shipping_address || {},
          delivery_option: data.delivery_option || {},
          tracking_number: data.tracking_number,
          notes: data.notes,
          created_at: data.created_at,
          updated_at: data.updated_at,
          delivered_at: data.delivered_at,
        };

        return order;
      }
    } catch (error: any) {
      console.error('Error fetching order by number and email:', {
        message: error?.message || 'Unknown error',
        code: error?.code,
        details: error?.details,
        hint: error?.hint,
        error: error,
      });
      
      // Return null if order not found, throw for other errors
      if (error?.code === 'PGRST116' || error?.message?.includes('No rows') || error?.message?.includes('not found')) {
        return null;
      }
      throw error;
    }
  },

  // Update order status (Admin)
  async updateOrderStatus(orderId: string, status: string) {
    const { data, error } = await supabase
      .from('orders')
      .update({ status })
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Update payment status
  async updatePaymentStatus(orderId: string, paymentStatus: string, reference?: string) {
    const updates: any = { payment_status: paymentStatus };
    
    if (reference) {
      updates.payment_reference = reference;
    }

    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Get all orders (Admin)
  async getAllOrders(page: number = 1, limit: number = 20) {
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const { data, error, count } = await supabase
      .from('orders')
      .select('*, items:order_items(*), user:users(full_name, email)', { count: 'exact' })
      .range(from, to)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return {
      orders: data || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        totalPages: Math.ceil((count || 0) / limit),
      },
    };
  },

  // Cancel order
  async cancelOrder(orderId: string) {
    const { data, error } = await supabase
      .from('orders')
      .update({ status: 'cancelled' })
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },
};


