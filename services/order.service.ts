import { supabase } from '@/lib/supabase';
import { CheckoutData, Order } from '@/types/order';

export const orderService = {
  // Create new order (supports guest checkout with null userId)
  // Uses backend API to handle emails and notifications
  async createOrder(checkoutData: CheckoutData, userId: string | null) {
    const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
    
    // Calculate totals
    // Use delivery_fee from checkoutData if provided (for pre-orders), otherwise calculate from delivery_option
    const subtotal = checkoutData.items.reduce((sum, item) => sum + item.subtotal, 0);
    const deliveryFee = checkoutData.delivery_fee !== undefined 
      ? checkoutData.delivery_fee 
      : (checkoutData.delivery_option?.price || 0);
    const tax = checkoutData.tax !== undefined ? checkoutData.tax : (subtotal * 0.0); // Ghana VAT if applicable
    const discount = checkoutData.discount || 0;
    // Calculate total: subtotal + delivery + tax - discount
    const total = checkoutData.total !== undefined 
      ? checkoutData.total 
      : (subtotal + deliveryFee + tax - discount);

    // Order number will be generated by backend for sequential numbering
    // Frontend should not generate order number - backend handles it

    // Map items for backend
    // Calculate unit_price including variant adjustments
    const order_items = checkoutData.items.map((item) => {
      // Calculate base price
      const basePrice = item.discount_price || item.original_price || 0;
      
      // Calculate variant adjustments from selected_variants
      const variantAdjustments = Object.values(item.selected_variants || {}).reduce(
        (sum: number, variant: any) => {
          // Handle both VariantOption format (price_modifier) and ProductVariant format (price_adjustment)
          const adjustment = variant.price_adjustment ?? variant.price_modifier ?? 0;
          return sum + (Number(adjustment) || 0);
        },
        0
      );
      
      // Unit price should be base price + variant adjustments
      const unitPrice = basePrice + variantAdjustments;
      
      // Ensure subtotal is calculated correctly
      const calculatedSubtotal = item.subtotal || (unitPrice * item.quantity);
      
      // CartItem extends Product, so it has an 'id' property (not 'product_id')
      const productId = item.id;
      
      if (!productId) {
        throw new Error(`Item missing id: ${JSON.stringify(item)}`);
      }
      
      return {
        product_id: productId,
        product_name: item.name,
        product_image: item.thumbnail || item.images?.[0] || '',
        quantity: item.quantity,
        unit_price: unitPrice, // Include variant adjustments in unit_price
        subtotal: calculatedSubtotal,
        selected_variants: item.selected_variants,
      };
    });

    // Try to call backend API first, fallback to Supabase if it fails
    try {
      const orderPayload = {
        user_id: userId,
        // order_number not provided - backend will generate sequential number
        subtotal,
        discount: checkoutData.discount || 0,
        coupon_id: (checkoutData as any).coupon_id || null,
        tax,
        delivery_fee: deliveryFee,
        total,
        payment_method: checkoutData.payment_method,
        delivery_address: checkoutData.delivery_address, // Backend will map this to shipping_address
        delivery_option: checkoutData.delivery_option,
        notes: checkoutData.notes || null,
        payment_reference: checkoutData.payment_reference || null, // Include payment reference for transaction linking
        order_items,
        // Pre-order fields
        is_pre_order: (checkoutData as any).is_pre_order || false,
        pre_order_shipping_option: (checkoutData as any).pre_order_shipping_option || null,
        estimated_arrival_date: (checkoutData as any).estimated_arrival_date || null,
      };
      
      console.log('Creating order via backend API:', {
        API_URL,
        endpoint: `${API_URL}/api/orders`,
        payload: {
          ...orderPayload,
          order_items: orderPayload.order_items.map(item => ({
            product_id: item.product_id,
            quantity: item.quantity,
            unit_price: item.unit_price,
          })),
        },
      });
      
      const response = await fetch(`${API_URL}/api/orders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderPayload),
      });
      
      // Backend API response received

      if (response.ok) {
        const result = await response.json();
        if (result.success && result.data) {
          return result.data;
        } else {
          throw new Error(result.message || 'Order creation failed');
        }
      } else {
        // Try to parse error response
        let errorMessage = 'Backend API failed';
        let errorData: any = {};
        try {
          errorData = await response.json();
          // Check multiple possible error message fields
          errorMessage = errorData.message || errorData.error || errorData.details || errorMessage;
          
          // If error message contains product-related issues, make it user-friendly
          if (errorMessage.includes('product_id') || errorMessage.includes('Products not found') || errorMessage.includes('foreign key constraint')) {
            errorMessage = 'Some products in your order are no longer available. Please remove them from your cart and try again.';
          }
          
          console.error('Backend API error response:', {
            status: response.status,
            statusText: response.statusText,
            error: errorData,
            message: errorMessage,
          });
        } catch (parseError) {
          errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
          console.error('Backend API error (non-JSON):', {
            status: response.status,
            statusText: response.statusText,
          });
        }
        
        // Don't fallback to Supabase - throw error instead
        // Supabase RLS will block frontend inserts anyway
        const error = new Error(errorMessage);
        (error as any).response = { status: response.status, data: errorData };
        throw error;
      }
    } catch (apiError: any) {
      // Don't fallback to Supabase - RLS will block it
      // Instead, throw the error so the user knows what went wrong
      console.error('Backend API failed - cannot create order:', {
        error: apiError,
        message: apiError?.message,
        status: apiError?.response?.status,
        responseData: apiError?.response?.data,
      });
      
      // Re-throw with a clearer message, but preserve the actual error message if it's user-friendly
      if (apiError?.message?.includes('products are no longer available') || 
          apiError?.message?.includes('Products not found') ||
          apiError?.message?.includes('product_id')) {
        // Already user-friendly, use as-is
        throw apiError;
      } else if (apiError?.response?.status === 500) {
        // For 500 errors, use the actual error message from backend if available
        const backendError = apiError?.response?.data?.error || apiError?.response?.data?.message;
        if (backendError && !backendError.includes('Unknown error')) {
          throw new Error(backendError);
        }
        throw new Error('Server error: Unable to create order. Please try again or contact support.');
      } else if (apiError?.response?.status === 400) {
        throw new Error(apiError.message || 'Invalid order data. Please check your order details.');
      } else if (apiError?.message?.includes('Failed to fetch') || apiError?.message?.includes('NetworkError')) {
        throw new Error('Network error: Unable to connect to server. Please check your internet connection and try again.');
      } else {
        throw apiError;
      }
    }
  },

  // Get user orders
  async getUserOrders(userId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return data || [];
  },

  // Get order by ID (uses backend API to support both authenticated and guest orders)
  async getOrderById(orderId: string) {
    const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
    
    try {
      const response = await fetch(`${API_URL}/api/orders/${orderId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('Order not found');
        }
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Failed to fetch order');
      }

      const result = await response.json();
      if (result.success && result.data) {
        // Transform the data to match Order interface
        const data = result.data;
        return {
          ...data,
          items: data.order_items || data.items || [],
          delivery_address: data.shipping_address || data.delivery_address,
          delivery_fee: data.shipping_fee || data.delivery_fee || 0,
        };
      } else {
        throw new Error(result.message || 'Failed to fetch order');
      }
    } catch (error: any) {
      console.error('Error fetching order by ID:', error);
      // Re-throw with a clearer message
      if (error.message?.includes('not found') || error.message?.includes('404')) {
        throw new Error('Order not found');
      }
      throw error;
    }
  },

  // Get order by order number
  async getOrderByNumber(orderNumber: string): Promise<Order | null> {
    try {
      const { data, error } = await supabase
        .from('orders')
        .select(`
          *,
          items:order_items(*)
        `)
        .eq('order_number', orderNumber.toUpperCase().trim())
        .single();

      if (error) {
        // If order not found, return null instead of throwing
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }

      if (!data) return null;

      // Transform the data to match Order interface
      const order: Order = {
        id: data.id,
        user_id: data.user_id,
        order_number: data.order_number,
        status: data.status,
        items: (data.items || []).map((item: any) => ({
          id: item.id,
          order_id: item.order_id,
          product_id: item.product_id,
          product_name: item.product_name,
          product_image: item.product_image,
          quantity: item.quantity,
          unit_price: item.unit_price,
          subtotal: item.subtotal || (item.unit_price * item.quantity),
          selected_variants: item.selected_variants || {},
        })),
        subtotal: data.subtotal || 0,
        discount: data.discount || 0,
        delivery_fee: data.delivery_fee || data.shipping_fee || 0,
        tax: data.tax || 0,
        total: data.total || 0,
        payment_method: data.payment_method,
        payment_status: data.payment_status,
        delivery_address: data.delivery_address || data.shipping_address || {},
        delivery_option: data.delivery_option || {},
        tracking_number: data.tracking_number,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        delivered_at: data.delivered_at,
      };

      return order;
    } catch (error: any) {
      console.error('Error fetching order by number:', error);
      // Return null if order not found, throw for other errors
      if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
        return null;
      }
      throw error;
    }
  },

  async getOrderByNumberAndEmail(orderNumberOrId: string, email: string): Promise<Order | null> {
    try {
      // Use backend API to bypass RLS and verify email
      const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
      
      try {
        const response = await fetch(`${API_URL}/api/orders/track`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            order_number_or_id: orderNumberOrId,
            email: email.trim().toLowerCase(),
          }),
        });

        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            // Transform the data to match Order interface
            const data = result.data;
            const order: Order = {
              id: data.id,
              user_id: data.user_id,
              order_number: data.order_number,
              status: data.status,
              items: (data.items || data.order_items || []).map((item: any) => ({
                id: item.id,
                order_id: item.order_id,
                product_id: item.product_id,
                product_name: item.product_name,
                product_image: item.product_image,
                quantity: item.quantity,
                unit_price: item.unit_price,
                subtotal: item.subtotal || (item.unit_price * item.quantity),
                selected_variants: item.selected_variants || {},
              })),
              subtotal: data.subtotal || 0,
              discount: data.discount || 0,
              delivery_fee: data.delivery_fee || data.shipping_fee || 0,
              tax: data.tax || 0,
              total: data.total || 0,
              payment_method: data.payment_method,
              payment_status: data.payment_status,
              delivery_address: data.delivery_address || data.shipping_address || {},
              delivery_option: data.delivery_option || {},
              tracking_number: data.tracking_number,
              notes: data.notes,
              created_at: data.created_at,
              updated_at: data.updated_at,
              delivered_at: data.delivered_at,
            };
            return order;
          } else {
            // Order not found or email doesn't match
            return null;
          }
        } else if (response.status === 404) {
          // Order not found
          return null;
        } else {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || 'Failed to fetch order');
        }
      } catch (apiError: any) {
        console.warn('Backend API failed, trying Supabase fallback:', apiError);
        
        // Fallback to Supabase direct query
        // First, try to find order by order_number
        let { data, error } = await supabase
          .from('orders')
          .select(`
            *,
            items:order_items(*),
            user:users!orders_user_id_fkey(id, email)
          `)
          .eq('order_number', orderNumberOrId)
          .maybeSingle();

        // If not found by order_number, try by id
        if (error || !data) {
          const { data: dataById, error: errorById } = await supabase
            .from('orders')
            .select(`
              *,
              items:order_items(*),
              user:users!orders_user_id_fkey(id, email)
            `)
            .eq('id', orderNumberOrId)
            .maybeSingle();
          
          data = dataById;
          error = errorById;
        }

        if (error) {
          console.error('Supabase query error:', {
            code: error.code,
            message: error.message,
            details: error.details,
            hint: error.hint,
          });
          
          // If order not found, return null instead of throwing
          if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
            return null;
          }
          throw new Error(`Database error: ${error.message || 'Unknown error'}`);
        }

        if (!data) return null;

        // Check if email matches
        // Email can be in:
        // 1. user.email (if order has a user_id)
        // 2. delivery_address.email or shipping_address.email (for guest orders)
        const userEmail = data.user?.email?.toLowerCase();
        const deliveryEmail = (data.delivery_address?.email || data.shipping_address?.email)?.toLowerCase();
        const providedEmail = email.toLowerCase().trim();

        const emailMatches = 
          userEmail === providedEmail || 
          deliveryEmail === providedEmail;

        if (!emailMatches) {
          // Email doesn't match - return null for security
          return null;
        }

        // Transform the data to match Order interface
        const order: Order = {
          id: data.id,
          user_id: data.user_id,
          order_number: data.order_number,
          status: data.status,
          items: (data.items || []).map((item: any) => ({
            id: item.id,
            order_id: item.order_id,
            product_id: item.product_id,
            product_name: item.product_name,
            product_image: item.product_image,
            quantity: item.quantity,
            unit_price: item.unit_price,
            subtotal: item.subtotal || (item.unit_price * item.quantity),
            selected_variants: item.selected_variants || {},
          })),
          subtotal: data.subtotal || 0,
          discount: data.discount || 0,
          delivery_fee: data.delivery_fee || data.shipping_fee || 0,
          tax: data.tax || 0,
          total: data.total || 0,
          payment_method: data.payment_method,
          payment_status: data.payment_status,
          delivery_address: data.delivery_address || data.shipping_address || {},
          delivery_option: data.delivery_option || {},
          tracking_number: data.tracking_number,
          notes: data.notes,
          created_at: data.created_at,
          updated_at: data.updated_at,
          delivered_at: data.delivered_at,
        };

        return order;
      }
    } catch (error: any) {
      console.error('Error fetching order by number and email:', {
        message: error?.message || 'Unknown error',
        code: error?.code,
        details: error?.details,
        hint: error?.hint,
        error: error,
      });
      
      // Return null if order not found, throw for other errors
      if (error?.code === 'PGRST116' || error?.message?.includes('No rows') || error?.message?.includes('not found')) {
        return null;
      }
      throw error;
    }
  },

  // Update order status (Admin)
  async updateOrderStatus(orderId: string, status: string) {
    const { data, error } = await supabase
      .from('orders')
      .update({ status })
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Update payment status
  async updatePaymentStatus(orderId: string, paymentStatus: string, reference?: string) {
    const updates: any = { payment_status: paymentStatus };
    
    if (reference) {
      updates.payment_reference = reference;
    }

    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Get all orders (Admin)
  async getAllOrders(page: number = 1, limit: number = 20) {
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const { data, error, count } = await supabase
      .from('orders')
      .select('*, items:order_items(*), user:users(full_name, email)', { count: 'exact' })
      .range(from, to)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return {
      orders: data || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        totalPages: Math.ceil((count || 0) / limit),
      },
    };
  },

  // Cancel order (works for both logged-in and anonymous users)
  async cancelOrder(orderId: string, email?: string): Promise<Order> {
    const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';
    
    try {
      const response = await fetch(`${API_URL}/api/orders/${orderId}/cancel`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email, // For anonymous users, verify via email
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Failed to cancel order');
      }

      const result = await response.json();
      return result.data;
    } catch (error: any) {
      console.error('Error cancelling order:', error);
      throw error;
    }
  },
};


